<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Benchmark Graphs</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<h2>Kyber Time Benchmark (Minutes)</h2>
<canvas id="kyberTimeChart"></canvas>

<h2>Kyber Size Benchmark (Bytes)</h2>
<canvas id="kyberSizeChart"></canvas>

<h2>Signature Time Benchmark (Dilithium & SPHINCS+) - Minutes</h2>
<canvas id="signatureTimeChart"></canvas>

<h2>Signature Size Benchmark (Dilithium & SPHINCS+) - Bytes</h2>
<canvas id="signatureSizeChart"></canvas>

<script>
    async function loadBenchmarkData() {
        try {
            const response = await fetch("../Results/benchmark_results.json");
            const jsonData = await response.json();
            generateKyberTimeGraph(jsonData);
            generateKyberSizeGraph(jsonData);
            generateSignatureTimeGraph(jsonData);
            generateSignatureSizeGraph(jsonData);
        } catch (error) {
            console.error("Error loading JSON:", error);
        }
    }

    function convertMsToMinutes(ms) {
        return ms / 60000; // Convert milliseconds to minutes
    }

    function parseSizeToBytes(value, unit) {
        if (unit === "KB") return parseFloat(value) * 1024;
        if (unit === "MB") return parseFloat(value) * 1024 * 1024;
        return parseFloat(value); // Default to bytes (B)
    }

    function generateKyberTimeGraph(data) {
        const algorithms = [];
        const keyGenTimes = [];
        const encapsulationTimes = [];
        const decapsulationTimes = [];

        for (const algorithm in data["Kyber"]) {
            algorithms.push(algorithm);
            keyGenTimes.push(convertMsToMinutes(data["Kyber"][algorithm].keyGenTime?.value) || 0);
            encapsulationTimes.push(convertMsToMinutes(data["Kyber"][algorithm].encapsulationTime?.value) || 0);
            decapsulationTimes.push(convertMsToMinutes(data["Kyber"][algorithm].decapsulationTime?.value) || 0);
        }

        new Chart(document.getElementById("kyberTimeChart").getContext("2d"), {
            type: "bar",
            data: {
                labels: algorithms,
                datasets: [
                    { label: "KeyGen Time (Minutes)", data: keyGenTimes, backgroundColor: "rgba(54, 162, 235, 0.6)" },
                    { label: "Encapsulation Time (Minutes)", data: encapsulationTimes, backgroundColor: "rgba(255, 99, 132, 0.6)" },
                    { label: "Decapsulation Time (Minutes)", data: decapsulationTimes, backgroundColor: "rgba(75, 192, 192, 0.6)" }
                ]
            },
            options: {
                responsive: true,
                scales: { y: { beginAtZero: true, title: { display: true, text: "Time (Minutes)" } } }
            }
        });
    }

    function generateKyberSizeGraph(data) {
        const algorithms = [];
        const keySizes = [];
        const ciphertextSizes = [];
        const sharedSecretSizes = [];

        for (const algorithm in data["Kyber"]) {
            algorithms.push(algorithm);
            keySizes.push(parseSizeToBytes(data["Kyber"][algorithm].keySize?.value, data["Kyber"][algorithm].keySize?.unit) || 0);
            ciphertextSizes.push(parseSizeToBytes(data["Kyber"][algorithm].ciphertextSize?.value, data["Kyber"][algorithm].ciphertextSize?.unit) || 0);
            sharedSecretSizes.push(32);
        }

        new Chart(document.getElementById("kyberSizeChart").getContext("2d"), {
            type: "bar",
            data: {
                labels: algorithms,
                datasets: [
                    { label: "Key Size (Bytes)", data: keySizes, backgroundColor: "rgba(255, 206, 86, 0.6)" },
                    { label: "Ciphertext Size (Bytes)", data: ciphertextSizes, backgroundColor: "rgba(153, 102, 255, 0.6)" },
                    { label: "Shared Secret Size (Bytes)", data: sharedSecretSizes, backgroundColor: "rgba(255, 159, 64, 0.6)" }
                ]
            },
            options: {
                responsive: true,
                scales: { y: { beginAtZero: true, title: { display: true, text: "Size (Bytes)" } } }
            }
        });
    }

    function generateSignatureTimeGraph(data) {
        const algorithms = [];
        const keyGenTimes = [];
        const signingTimes = [];
        const verificationTimes = [];

        ["Dilithium", "SPHINCS+"].forEach(category => {
            for (const algorithm in data[category]) {
                algorithms.push(algorithm);
                keyGenTimes.push(convertMsToMinutes(data[category][algorithm].keyGenTime?.value) || 0);
                signingTimes.push(convertMsToMinutes(data[category][algorithm].signingTime?.value) || 0);
                verificationTimes.push(convertMsToMinutes(data[category][algorithm].verificationTime?.value) || 0);
            }
        });

        new Chart(document.getElementById("signatureTimeChart").getContext("2d"), {
            type: "bar",
            data: {
                labels: algorithms,
                datasets: [
                    { label: "KeyGen Time (Minutes)", data: keyGenTimes, backgroundColor: "rgba(54, 162, 235, 0.6)" },
                    { label: "Signing Time (Minutes)", data: signingTimes, backgroundColor: "rgba(255, 99, 132, 0.6)" },
                    { label: "Verification Time (Minutes)", data: verificationTimes, backgroundColor: "rgba(75, 192, 192, 0.6)" }
                ]
            },
            options: {
                responsive: true,
                scales: { y: { beginAtZero: true, title: { display: true, text: "Time (Minutes)" } } }
            }
        });
    }

    function generateSignatureSizeGraph(data) {
        const algorithms = [];
        const keySizes = [];
        const signatureSizes = [];

        ["Dilithium", "SPHINCS+"].forEach(category => {
            for (const algorithm in data[category]) {
                algorithms.push(algorithm);
                keySizes.push(parseSizeToBytes(data[category][algorithm].keySize?.value, data[category][algorithm].keySize?.unit) || 0);
                signatureSizes.push(parseSizeToBytes(data[category][algorithm].signatureSize?.value, data[category][algorithm].signatureSize?.unit) || 0);
            }
        });

        new Chart(document.getElementById("signatureSizeChart").getContext("2d"), {
            type: "bar",
            data: {
                labels: algorithms,
                datasets: [
                    { label: "Key Size (Bytes)", data: keySizes, backgroundColor: "rgba(255, 206, 86, 0.6)" },
                    { label: "Signature Size (Bytes)", data: signatureSizes, backgroundColor: "rgba(153, 102, 255, 0.6)" }
                ]
            },
            options: {
                responsive: true,
                scales: { y: { beginAtZero: true, title: { display: true, text: "Size (Bytes)" } } }
            }
        });
    }

    loadBenchmarkData();
</script>

</body>
</html>
